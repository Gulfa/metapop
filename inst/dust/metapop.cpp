// Generated by odin.dust (version 0.2.13) - do not edit
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum1(const container x, size_t from, size_t to);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum3(const container x, int from_i, int to_i, int from_j, int to_j, int from_k, int to_k, int dim_x_1, int dim_x_12);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum5(const container x, int from_i, int to_i, int from_j, int to_j, int from_k, int to_k, int from_l, int to_l, int from_i5, int to_i5, int dim_x_1, int dim_x_12, int dim_x_123, int dim_x_1234);
template <typename real_type, typename T, typename U>
__host__ __device__ real_type fmodr(T x, U y) {
  real_type tmp = std::fmod(static_cast<real_type>(x),
                            static_cast<real_type>(y));
  if (tmp * y < 0) {
    tmp += y;
  }
  return tmp;
}

// These exist to support the model on the gpu, as in C++14 std::min
// and std::max are constexpr and error without --expt-relaxed-constexpr
template <typename T>
__host__ __device__ T odin_min(T x, T y) {
  return x < y ? x : y;
}

template <typename T>
__host__ __device__ T odin_max(T x, T y) {
  return x > y ? x : y;
}
// [[dust::class(metapop)]]
// [[dust::param(I_ini, has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(N_steps, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(R_ini, has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(S_ini, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_day, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_norm, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_strain, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(cross_protection, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(mixing_matrix, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(n_strain, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(n_vac, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(susceptibility, has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(transmisibility, has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dt, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gamma, has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(import, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(n, has_default = TRUE, default_value = 4L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class metapop {
public:
  typedef double real_type;
  typedef dust::random::generator<real_type> rng_state_type;
  typedef dust::no_data data_type;
  struct shared_type {
    std::vector<real_type> I_ini;
    int N_steps;
    std::vector<real_type> R_ini;
    std::vector<real_type> S_ini;
    std::vector<real_type> beta_day;
    std::vector<real_type> beta_norm;
    std::vector<real_type> beta_strain;
    std::vector<real_type> cross_protection;
    int dim_I;
    int dim_I_1;
    int dim_I_12;
    int dim_I_2;
    int dim_I_3;
    int dim_I_ini;
    int dim_I_ini_1;
    int dim_I_ini_12;
    int dim_I_ini_2;
    int dim_I_ini_3;
    int dim_N;
    int dim_N_1;
    int dim_N_2;
    int dim_R;
    int dim_R_1;
    int dim_R_12;
    int dim_R_2;
    int dim_R_3;
    int dim_R_ini;
    int dim_R_ini_1;
    int dim_R_ini_12;
    int dim_R_ini_2;
    int dim_R_ini_3;
    int dim_S;
    int dim_S_1;
    int dim_S_2;
    int dim_S_ini;
    int dim_S_ini_1;
    int dim_S_ini_2;
    int dim_beta_day;
    int dim_beta_norm;
    int dim_beta_strain;
    int dim_cross_protection;
    int dim_cross_protection_1;
    int dim_cross_protection_2;
    int dim_inc;
    int dim_inc_1;
    int dim_inc_12;
    int dim_inc_2;
    int dim_inc_3;
    int dim_lambda_ij;
    int dim_lambda_ij_1;
    int dim_lambda_ij_12;
    int dim_lambda_ij_123;
    int dim_lambda_ij_1234;
    int dim_lambda_ij_2;
    int dim_lambda_ij_3;
    int dim_lambda_ij_4;
    int dim_lambda_ij_5;
    int dim_mixing_matrix;
    int dim_mixing_matrix_1;
    int dim_mixing_matrix_2;
    int dim_n_IR;
    int dim_n_IR_1;
    int dim_n_IR_12;
    int dim_n_IR_2;
    int dim_n_IR_3;
    int dim_n_RI;
    int dim_n_RI_1;
    int dim_n_RI_12;
    int dim_n_RI_2;
    int dim_n_RI_3;
    int dim_n_RI_op;
    int dim_n_RI_op_1;
    int dim_n_RI_op_12;
    int dim_n_RI_op_2;
    int dim_n_RI_op_3;
    int dim_n_SI;
    int dim_n_SI_1;
    int dim_n_SI_12;
    int dim_n_SI_2;
    int dim_n_SI_3;
    int dim_n_SI_tot;
    int dim_n_SI_tot_1;
    int dim_n_SI_tot_2;
    int dim_p_SI;
    int dim_p_SI_1;
    int dim_p_SI_12;
    int dim_p_SI_2;
    int dim_p_SI_3;
    int dim_rel_strain;
    int dim_rel_strain_1;
    int dim_rel_strain_12;
    int dim_rel_strain_2;
    int dim_rel_strain_3;
    int dim_susceptibility;
    int dim_susceptibility_1;
    int dim_susceptibility_12;
    int dim_susceptibility_2;
    int dim_susceptibility_3;
    int dim_transmisibility;
    int dim_transmisibility_1;
    int dim_transmisibility_12;
    int dim_transmisibility_2;
    int dim_transmisibility_3;
    real_type dt;
    real_type gamma;
    real_type import;
    std::vector<real_type> initial_I;
    std::vector<real_type> initial_R;
    std::vector<real_type> initial_S;
    std::vector<real_type> initial_inc;
    real_type initial_time;
    std::vector<real_type> mixing_matrix;
    int n;
    int n_strain;
    int n_vac;
    int offset_variable_I;
    int offset_variable_R;
    int offset_variable_inc;
    real_type p_IR;
    real_type steps_per_day;
    std::vector<real_type> susceptibility;
    std::vector<real_type> transmisibility;
  };
  struct internal_type {
    std::vector<real_type> N;
    std::vector<real_type> lambda_ij;
    std::vector<real_type> n_IR;
    std::vector<real_type> n_RI;
    std::vector<real_type> n_RI_op;
    std::vector<real_type> n_SI;
    std::vector<real_type> n_SI_tot;
    std::vector<real_type> p_SI;
    std::vector<real_type> rel_strain;
  };
  metapop(const dust::pars_type<metapop>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() {
    return shared->dim_I + shared->dim_R + shared->dim_S + shared->dim_inc + 1;
  }
  std::vector<real_type> initial(size_t step) {
    std::vector<real_type> state(shared->dim_I + shared->dim_R + shared->dim_S + shared->dim_inc + 1);
    state[0] = shared->initial_time;
    std::copy(shared->initial_S.begin(), shared->initial_S.end(), state.begin() + 1);
    std::copy(shared->initial_I.begin(), shared->initial_I.end(), state.begin() + shared->offset_variable_I);
    std::copy(shared->initial_R.begin(), shared->initial_R.end(), state.begin() + shared->offset_variable_R);
    std::copy(shared->initial_inc.begin(), shared->initial_inc.end(), state.begin() + shared->offset_variable_inc);
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type * S = state + 1;
    const real_type * I = state + shared->offset_variable_I;
    const real_type * R = state + shared->offset_variable_R;
    const real_type * inc = state + shared->offset_variable_inc;
    state_next[0] = (step + 1) * shared->dt;
    real_type beta = shared->beta_day[step - 1];
    for (int i = 1; i <= shared->dim_N_1; ++i) {
      for (int j = 1; j <= shared->dim_N_2; ++j) {
        internal.N[i - 1 + shared->dim_N_1 * (j - 1)] = S[shared->dim_S_1 * (j - 1) + i - 1] + odin_sum3<real_type>(I, i - 1, i, j - 1, j, 0, shared->dim_I_3, shared->dim_I_1, shared->dim_I_12) + odin_sum3<real_type>(R, i - 1, i, j - 1, j, 0, shared->dim_R_3, shared->dim_R_1, shared->dim_R_12);
      }
    }
    for (int i = 1; i <= shared->dim_n_IR_1; ++i) {
      for (int j = 1; j <= shared->dim_n_IR_2; ++j) {
        for (int k = 1; k <= shared->dim_n_IR_3; ++k) {
          internal.n_IR[i - 1 + shared->dim_n_IR_1 * (j - 1) + shared->dim_n_IR_12 * (k - 1)] = dust::random::binomial<real_type>(rng_state, I[shared->dim_I_12 * (k - 1) + shared->dim_I_1 * (j - 1) + i - 1], shared->p_IR);
        }
      }
    }
    for (int i = 1; i <= shared->dim_lambda_ij_1; ++i) {
      for (int j = 1; j <= shared->dim_lambda_ij_2; ++j) {
        for (int k = 1; k <= shared->dim_lambda_ij_3; ++k) {
          for (int l = 1; l <= shared->dim_lambda_ij_4; ++l) {
            for (int i5 = 1; i5 <= shared->dim_lambda_ij_5; ++i5) {
              internal.lambda_ij[i - 1 + shared->dim_lambda_ij_1 * (j - 1) + shared->dim_lambda_ij_12 * (k - 1) + shared->dim_lambda_ij_123 * (l - 1) + shared->dim_lambda_ij_1234 * (i5 - 1)] = beta * shared->beta_strain[i5 - 1] * shared->mixing_matrix[shared->dim_mixing_matrix_1 * (l - 1) + i - 1] * I[shared->dim_I_12 * (i5 - 1) + shared->dim_I_1 * (l - 1) + k - 1] / (real_type) odin_sum1<real_type>(internal.N.data(), 0, shared->dim_N) * shared->susceptibility[shared->dim_susceptibility_12 * (i5 - 1) + shared->dim_susceptibility_1 * (j - 1) + i - 1] * shared->transmisibility[shared->dim_transmisibility_12 * (i5 - 1) + shared->dim_transmisibility_1 * (l - 1) + k - 1];
            }
          }
        }
      }
    }
    for (int i = 1; i <= shared->dim_n_RI_1; ++i) {
      for (int j = 1; j <= shared->dim_n_RI_2; ++j) {
        int k = 2;
        internal.n_RI[i - 1 + shared->dim_n_RI_1 * (j - 1) + shared->dim_n_RI_12 * (k - 1)] = dust::random::binomial<real_type>(rng_state, R[shared->dim_R_12 * 1 + shared->dim_R_1 * (j - 1) + i - 1], 1 - std::exp(- odin_sum5<real_type>(internal.lambda_ij.data(), i - 1, i, j - 1, j, 0, shared->dim_lambda_ij_3, 0, shared->dim_lambda_ij_4, 0, 1, shared->dim_lambda_ij_1, shared->dim_lambda_ij_12, shared->dim_lambda_ij_123, shared->dim_lambda_ij_1234) * shared->cross_protection[shared->dim_cross_protection_1 * 0 + 1] * shared->dt));
      }
    }
    for (int i = 1; i <= shared->dim_n_RI_1; ++i) {
      for (int j = 1; j <= shared->dim_n_RI_2; ++j) {
        int k = 1;
        internal.n_RI[i - 1 + shared->dim_n_RI_1 * (j - 1) + shared->dim_n_RI_12 * (k - 1)] = dust::random::binomial<real_type>(rng_state, R[shared->dim_R_12 * 0 + shared->dim_R_1 * (j - 1) + i - 1], 1 - std::exp(- odin_sum5<real_type>(internal.lambda_ij.data(), i - 1, i, j - 1, j, 0, shared->dim_lambda_ij_3, 0, shared->dim_lambda_ij_4, 0, 1, shared->dim_lambda_ij_1, shared->dim_lambda_ij_12, shared->dim_lambda_ij_123, shared->dim_lambda_ij_1234) * shared->cross_protection[shared->dim_cross_protection_1 * 1 + 0] * shared->dt));
      }
    }
    for (int i = 1; i <= shared->dim_p_SI_1; ++i) {
      for (int j = 1; j <= shared->dim_p_SI_2; ++j) {
        for (int k = 1; k <= shared->dim_p_SI_3; ++k) {
          internal.p_SI[i - 1 + shared->dim_p_SI_1 * (j - 1) + shared->dim_p_SI_12 * (k - 1)] = 1 - std::exp(- odin_sum5<real_type>(internal.lambda_ij.data(), i - 1, i, j - 1, j, 0, shared->dim_lambda_ij_3, 0, shared->dim_lambda_ij_4, k - 1, k, shared->dim_lambda_ij_1, shared->dim_lambda_ij_12, shared->dim_lambda_ij_123, shared->dim_lambda_ij_1234) * shared->dt);
        }
      }
    }
    for (int i = 1; i <= shared->dim_n_RI_op_1; ++i) {
      for (int j = 1; j <= shared->dim_n_RI_op_2; ++j) {
        int k = 1;
        internal.n_RI_op[i - 1 + shared->dim_n_RI_op_1 * (j - 1) + shared->dim_n_RI_op_12 * (k - 1)] = internal.n_RI[shared->dim_n_RI_12 * 1 + shared->dim_n_RI_1 * (j - 1) + i - 1];
      }
    }
    for (int i = 1; i <= shared->dim_n_RI_op_1; ++i) {
      for (int j = 1; j <= shared->dim_n_RI_op_2; ++j) {
        int k = 2;
        internal.n_RI_op[i - 1 + shared->dim_n_RI_op_1 * (j - 1) + shared->dim_n_RI_op_12 * (k - 1)] = internal.n_RI[shared->dim_n_RI_12 * 0 + shared->dim_n_RI_1 * (j - 1) + i - 1];
      }
    }
    for (int i = 1; i <= shared->dim_n_SI_tot_1; ++i) {
      for (int j = 1; j <= shared->dim_n_SI_tot_2; ++j) {
        internal.n_SI_tot[i - 1 + shared->dim_n_SI_tot_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, S[shared->dim_S_1 * (j - 1) + i - 1], odin_sum3<real_type>(internal.p_SI.data(), i - 1, i, j - 1, j, 0, shared->dim_p_SI_3, shared->dim_p_SI_1, shared->dim_p_SI_12));
      }
    }
    for (int i = 1; i <= shared->dim_rel_strain_1; ++i) {
      for (int j = 1; j <= shared->dim_rel_strain_2; ++j) {
        for (int k = 1; k <= shared->dim_rel_strain_3; ++k) {
          internal.rel_strain[i - 1 + shared->dim_rel_strain_1 * (j - 1) + shared->dim_rel_strain_12 * (k - 1)] = internal.p_SI[shared->dim_p_SI_12 * (k - 1) + shared->dim_p_SI_1 * (j - 1) + i - 1] / (real_type) odin_sum3<real_type>(internal.p_SI.data(), i - 1, i, j - 1, j, 0, shared->dim_p_SI_3, shared->dim_p_SI_1, shared->dim_p_SI_12);
        }
      }
    }
    for (int i = 1; i <= shared->dim_R_1; ++i) {
      for (int j = 1; j <= shared->dim_R_2; ++j) {
        for (int k = 1; k <= shared->dim_R_3; ++k) {
          state_next[shared->offset_variable_R + i - 1 + shared->dim_R_1 * (j - 1) + shared->dim_R_12 * (k - 1)] = R[shared->dim_R_12 * (k - 1) + shared->dim_R_1 * (j - 1) + i - 1] + internal.n_IR[shared->dim_n_IR_12 * (k - 1) + shared->dim_n_IR_1 * (j - 1) + i - 1] - internal.n_RI[shared->dim_n_RI_12 * (k - 1) + shared->dim_n_RI_1 * (j - 1) + i - 1];
        }
      }
    }
    for (int i = 1; i <= shared->dim_n_SI_1; ++i) {
      for (int j = 1; j <= shared->dim_n_SI_2; ++j) {
        for (int k = 1; k <= shared->dim_n_SI_3; ++k) {
          internal.n_SI[i - 1 + shared->dim_n_SI_1 * (j - 1) + shared->dim_n_SI_12 * (k - 1)] = (k == 1 || shared->n_strain == 1 ? dust::random::binomial<real_type>(rng_state, internal.n_SI_tot[shared->dim_n_SI_tot_1 * (j - 1) + i - 1], internal.rel_strain[shared->dim_rel_strain_12 * (k - 1) + shared->dim_rel_strain_1 * (j - 1) + i - 1]) : ((k == 2 ? internal.n_SI_tot[shared->dim_n_SI_tot_1 * (j - 1) + i - 1] - internal.n_SI[shared->dim_n_SI_12 * 0 + shared->dim_n_SI_1 * (j - 1) + i - 1] : 0)));
        }
      }
    }
    for (int i = 1; i <= shared->dim_I_1; ++i) {
      for (int j = 1; j <= shared->dim_I_2; ++j) {
        for (int k = 1; k <= shared->dim_I_3; ++k) {
          state_next[shared->offset_variable_I + i - 1 + shared->dim_I_1 * (j - 1) + shared->dim_I_12 * (k - 1)] = I[shared->dim_I_12 * (k - 1) + shared->dim_I_1 * (j - 1) + i - 1] + internal.n_SI[shared->dim_n_SI_12 * (k - 1) + shared->dim_n_SI_1 * (j - 1) + i - 1] - internal.n_IR[shared->dim_n_IR_12 * (k - 1) + shared->dim_n_IR_1 * (j - 1) + i - 1] + internal.n_RI_op[shared->dim_n_RI_op_12 * (k - 1) + shared->dim_n_RI_op_1 * (j - 1) + i - 1];
        }
      }
    }
    for (int i = 1; i <= shared->dim_S_1; ++i) {
      for (int j = 1; j <= shared->dim_S_2; ++j) {
        state_next[1 + i - 1 + shared->dim_S_1 * (j - 1)] = S[shared->dim_S_1 * (j - 1) + i - 1] - odin_sum3<real_type>(internal.n_SI.data(), i - 1, i, j - 1, j, 0, shared->dim_n_SI_3, shared->dim_n_SI_1, shared->dim_n_SI_12);
      }
    }
    for (int i = 1; i <= shared->dim_inc_1; ++i) {
      for (int j = 1; j <= shared->dim_inc_2; ++j) {
        for (int k = 1; k <= shared->dim_inc_3; ++k) {
          state_next[shared->offset_variable_inc + i - 1 + shared->dim_inc_1 * (j - 1) + shared->dim_inc_12 * (k - 1)] = (fmodr<real_type>(step, shared->steps_per_day) == 0 ? internal.n_SI[shared->dim_n_SI_12 * (k - 1) + shared->dim_n_SI_1 * (j - 1) + i - 1] : inc[shared->dim_inc_12 * (k - 1) + shared->dim_inc_1 * (j - 1) + i - 1] + internal.n_SI[shared->dim_n_SI_12 * (k - 1) + shared->dim_n_SI_1 * (j - 1) + i - 1]);
        }
      }
    }
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  real_type tot = 0.0;
  for (int j = from_j; j < to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i < to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum3(const container x, int from_i, int to_i, int from_j, int to_j, int from_k, int to_k, int dim_x_1, int dim_x_12) {
  real_type tot = 0.0;
  for (int k = from_k; k < to_k; ++k) {
    int kk = k * dim_x_12;
    for (int j = from_j; j < to_j; ++j) {
      int jj = j * dim_x_1 + kk;
      for (int i = from_i; i < to_i; ++i) {
        tot += x[i + jj];
      }
    }
  }
  return tot;
}
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum5(const container x, int from_i, int to_i, int from_j, int to_j, int from_k, int to_k, int from_l, int to_l, int from_i5, int to_i5, int dim_x_1, int dim_x_12, int dim_x_123, int dim_x_1234) {
  real_type tot = 0.0;
  for (int i5 = from_i5; i5 < to_i5; ++i5) {
    int i5i5 = i5 * dim_x_1234;
    for (int l = from_l; l < to_l; ++l) {
      int ll = l * dim_x_123 + i5i5;
      for (int k = from_k; k < to_k; ++k) {
        int kk = k * dim_x_12 + ll;
        for (int j = from_j; j < to_j; ++j) {
          int jj = j * dim_x_1 + kk;
          for (int i = from_i; i < to_i; ++i) {
            tot += x[i + jj];
          }
        }
      }
    }
  }
  return tot;
}
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'", N, name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               i + 1, name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<metapop> dust_pars<metapop>(cpp11::list user) {
  typedef typename metapop::real_type real_type;
  auto shared = std::make_shared<metapop::shared_type>();
  metapop::internal_type internal;
  shared->initial_time = 0;
  shared->N_steps = NA_INTEGER;
  shared->n_strain = NA_INTEGER;
  shared->n_vac = NA_INTEGER;
  shared->dt = 1;
  shared->gamma = 0.10000000000000001;
  shared->import = 0;
  shared->n = 4;
  shared->N_steps = user_get_scalar<int>(user, "N_steps", shared->N_steps, NA_REAL, NA_REAL);
  shared->dt = user_get_scalar<real_type>(user, "dt", shared->dt, NA_REAL, NA_REAL);
  shared->gamma = user_get_scalar<real_type>(user, "gamma", shared->gamma, NA_REAL, NA_REAL);
  shared->import = user_get_scalar<real_type>(user, "import", shared->import, NA_REAL, NA_REAL);
  shared->n = user_get_scalar<int>(user, "n", shared->n, NA_REAL, NA_REAL);
  shared->n_strain = user_get_scalar<int>(user, "n_strain", shared->n_strain, NA_REAL, NA_REAL);
  shared->n_vac = user_get_scalar<int>(user, "n_vac", shared->n_vac, NA_REAL, NA_REAL);
  shared->dim_I_1 = shared->n;
  shared->dim_I_2 = shared->n_vac;
  shared->dim_I_3 = shared->n_strain;
  shared->dim_I_ini_1 = shared->n;
  shared->dim_I_ini_2 = shared->n_vac;
  shared->dim_I_ini_3 = shared->n_strain;
  shared->dim_N_1 = shared->n;
  shared->dim_N_2 = shared->n_vac;
  shared->dim_R_1 = shared->n;
  shared->dim_R_2 = shared->n_vac;
  shared->dim_R_3 = shared->n_strain;
  shared->dim_R_ini_1 = shared->n;
  shared->dim_R_ini_2 = shared->n_vac;
  shared->dim_R_ini_3 = shared->n_strain;
  shared->dim_S_1 = shared->n;
  shared->dim_S_2 = shared->n_vac;
  shared->dim_S_ini_1 = shared->n;
  shared->dim_S_ini_2 = shared->n_vac;
  shared->dim_beta_day = shared->N_steps;
  shared->dim_beta_norm = shared->n;
  shared->dim_beta_strain = shared->n_strain;
  shared->dim_cross_protection_1 = shared->n_strain;
  shared->dim_cross_protection_2 = shared->n_strain;
  shared->dim_inc_1 = shared->n;
  shared->dim_inc_2 = shared->n_vac;
  shared->dim_inc_3 = shared->n_strain;
  shared->dim_lambda_ij_1 = shared->n;
  shared->dim_lambda_ij_2 = shared->n_vac;
  shared->dim_lambda_ij_3 = shared->n;
  shared->dim_lambda_ij_4 = shared->n_vac;
  shared->dim_lambda_ij_5 = shared->n_strain;
  shared->dim_mixing_matrix_1 = shared->n;
  shared->dim_mixing_matrix_2 = shared->n;
  shared->dim_n_IR_1 = shared->n;
  shared->dim_n_IR_2 = shared->n_vac;
  shared->dim_n_IR_3 = shared->n_strain;
  shared->dim_n_RI_1 = shared->n;
  shared->dim_n_RI_2 = shared->n_vac;
  shared->dim_n_RI_3 = shared->n_strain;
  shared->dim_n_RI_op_1 = shared->n;
  shared->dim_n_RI_op_2 = shared->n_vac;
  shared->dim_n_RI_op_3 = shared->n_strain;
  shared->dim_n_SI_1 = shared->n;
  shared->dim_n_SI_2 = shared->n_vac;
  shared->dim_n_SI_3 = shared->n_strain;
  shared->dim_n_SI_tot_1 = shared->n;
  shared->dim_n_SI_tot_2 = shared->n_vac;
  shared->dim_p_SI_1 = shared->n;
  shared->dim_p_SI_2 = shared->n_vac;
  shared->dim_p_SI_3 = shared->n_strain;
  shared->dim_rel_strain_1 = shared->n;
  shared->dim_rel_strain_2 = shared->n_vac;
  shared->dim_rel_strain_3 = shared->n_strain;
  shared->dim_susceptibility_1 = shared->n;
  shared->dim_susceptibility_2 = shared->n_vac;
  shared->dim_susceptibility_3 = shared->n_strain;
  shared->dim_transmisibility_1 = shared->n;
  shared->dim_transmisibility_2 = shared->n_vac;
  shared->dim_transmisibility_3 = shared->n_strain;
  shared->p_IR = 1 - std::exp(- shared->gamma * shared->dt);
  shared->steps_per_day = 1 / (real_type) shared->dt;
  shared->beta_day = user_get_array_fixed<real_type, 1>(user, "beta_day", shared->beta_day, {shared->dim_beta_day}, NA_REAL, NA_REAL);
  shared->beta_norm = user_get_array_fixed<real_type, 1>(user, "beta_norm", shared->beta_norm, {shared->dim_beta_norm}, NA_REAL, NA_REAL);
  shared->beta_strain = user_get_array_fixed<real_type, 1>(user, "beta_strain", shared->beta_strain, {shared->dim_beta_strain}, NA_REAL, NA_REAL);
  shared->dim_I = shared->dim_I_1 * shared->dim_I_2 * shared->dim_I_3;
  shared->dim_I_12 = shared->dim_I_1 * shared->dim_I_2;
  shared->dim_I_ini = shared->dim_I_ini_1 * shared->dim_I_ini_2 * shared->dim_I_ini_3;
  shared->dim_I_ini_12 = shared->dim_I_ini_1 * shared->dim_I_ini_2;
  shared->dim_N = shared->dim_N_1 * shared->dim_N_2;
  shared->dim_R = shared->dim_R_1 * shared->dim_R_2 * shared->dim_R_3;
  shared->dim_R_12 = shared->dim_R_1 * shared->dim_R_2;
  shared->dim_R_ini = shared->dim_R_ini_1 * shared->dim_R_ini_2 * shared->dim_R_ini_3;
  shared->dim_R_ini_12 = shared->dim_R_ini_1 * shared->dim_R_ini_2;
  shared->dim_S = shared->dim_S_1 * shared->dim_S_2;
  shared->dim_S_ini = shared->dim_S_ini_1 * shared->dim_S_ini_2;
  shared->dim_cross_protection = shared->dim_cross_protection_1 * shared->dim_cross_protection_2;
  shared->dim_inc = shared->dim_inc_1 * shared->dim_inc_2 * shared->dim_inc_3;
  shared->dim_inc_12 = shared->dim_inc_1 * shared->dim_inc_2;
  shared->dim_lambda_ij = shared->dim_lambda_ij_1 * shared->dim_lambda_ij_2 * shared->dim_lambda_ij_3 * shared->dim_lambda_ij_4 * shared->dim_lambda_ij_5;
  shared->dim_lambda_ij_12 = shared->dim_lambda_ij_1 * shared->dim_lambda_ij_2;
  shared->dim_lambda_ij_123 = shared->dim_lambda_ij_1 * shared->dim_lambda_ij_2 * shared->dim_lambda_ij_3;
  shared->dim_lambda_ij_1234 = shared->dim_lambda_ij_1 * shared->dim_lambda_ij_2 * shared->dim_lambda_ij_3 * shared->dim_lambda_ij_4;
  shared->dim_mixing_matrix = shared->dim_mixing_matrix_1 * shared->dim_mixing_matrix_2;
  shared->dim_n_IR = shared->dim_n_IR_1 * shared->dim_n_IR_2 * shared->dim_n_IR_3;
  shared->dim_n_IR_12 = shared->dim_n_IR_1 * shared->dim_n_IR_2;
  shared->dim_n_RI = shared->dim_n_RI_1 * shared->dim_n_RI_2 * shared->dim_n_RI_3;
  shared->dim_n_RI_12 = shared->dim_n_RI_1 * shared->dim_n_RI_2;
  shared->dim_n_RI_op = shared->dim_n_RI_op_1 * shared->dim_n_RI_op_2 * shared->dim_n_RI_op_3;
  shared->dim_n_RI_op_12 = shared->dim_n_RI_op_1 * shared->dim_n_RI_op_2;
  shared->dim_n_SI = shared->dim_n_SI_1 * shared->dim_n_SI_2 * shared->dim_n_SI_3;
  shared->dim_n_SI_12 = shared->dim_n_SI_1 * shared->dim_n_SI_2;
  shared->dim_n_SI_tot = shared->dim_n_SI_tot_1 * shared->dim_n_SI_tot_2;
  shared->dim_p_SI = shared->dim_p_SI_1 * shared->dim_p_SI_2 * shared->dim_p_SI_3;
  shared->dim_p_SI_12 = shared->dim_p_SI_1 * shared->dim_p_SI_2;
  shared->dim_rel_strain = shared->dim_rel_strain_1 * shared->dim_rel_strain_2 * shared->dim_rel_strain_3;
  shared->dim_rel_strain_12 = shared->dim_rel_strain_1 * shared->dim_rel_strain_2;
  shared->dim_susceptibility = shared->dim_susceptibility_1 * shared->dim_susceptibility_2 * shared->dim_susceptibility_3;
  shared->dim_susceptibility_12 = shared->dim_susceptibility_1 * shared->dim_susceptibility_2;
  shared->dim_transmisibility = shared->dim_transmisibility_1 * shared->dim_transmisibility_2 * shared->dim_transmisibility_3;
  shared->dim_transmisibility_12 = shared->dim_transmisibility_1 * shared->dim_transmisibility_2;
  shared->I_ini = user_get_array_fixed<real_type, 3>(user, "I_ini", shared->I_ini, {shared->dim_I_ini_1, shared->dim_I_ini_2, shared->dim_I_ini_3}, NA_REAL, NA_REAL);
  shared->R_ini = user_get_array_fixed<real_type, 3>(user, "R_ini", shared->R_ini, {shared->dim_R_ini_1, shared->dim_R_ini_2, shared->dim_R_ini_3}, NA_REAL, NA_REAL);
  shared->S_ini = user_get_array_fixed<real_type, 2>(user, "S_ini", shared->S_ini, {shared->dim_S_ini_1, shared->dim_S_ini_2}, NA_REAL, NA_REAL);
  internal.N = std::vector<real_type>(shared->dim_N);
  shared->initial_I = std::vector<real_type>(shared->dim_I);
  shared->initial_R = std::vector<real_type>(shared->dim_R);
  shared->initial_S = std::vector<real_type>(shared->dim_S);
  shared->initial_inc = std::vector<real_type>(shared->dim_inc);
  internal.lambda_ij = std::vector<real_type>(shared->dim_lambda_ij);
  internal.n_IR = std::vector<real_type>(shared->dim_n_IR);
  internal.n_RI = std::vector<real_type>(shared->dim_n_RI);
  internal.n_RI_op = std::vector<real_type>(shared->dim_n_RI_op);
  internal.n_SI = std::vector<real_type>(shared->dim_n_SI);
  internal.n_SI_tot = std::vector<real_type>(shared->dim_n_SI_tot);
  internal.p_SI = std::vector<real_type>(shared->dim_p_SI);
  internal.rel_strain = std::vector<real_type>(shared->dim_rel_strain);
  shared->cross_protection = user_get_array_fixed<real_type, 2>(user, "cross_protection", shared->cross_protection, {shared->dim_cross_protection_1, shared->dim_cross_protection_2}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_inc_1; ++i) {
    for (int j = 1; j <= shared->dim_inc_2; ++j) {
      for (int k = 1; k <= shared->dim_inc_3; ++k) {
        shared->initial_inc[i - 1 + shared->dim_inc_1 * (j - 1) + shared->dim_inc_12 * (k - 1)] = 0;
      }
    }
  }
  shared->mixing_matrix = user_get_array_fixed<real_type, 2>(user, "mixing_matrix", shared->mixing_matrix, {shared->dim_mixing_matrix_1, shared->dim_mixing_matrix_2}, NA_REAL, NA_REAL);
  shared->offset_variable_I = shared->dim_S + 1;
  shared->offset_variable_R = shared->dim_I + shared->dim_S + 1;
  shared->offset_variable_inc = shared->dim_I + shared->dim_R + shared->dim_S + 1;
  shared->susceptibility = user_get_array_fixed<real_type, 3>(user, "susceptibility", shared->susceptibility, {shared->dim_susceptibility_1, shared->dim_susceptibility_2, shared->dim_susceptibility_3}, NA_REAL, NA_REAL);
  shared->transmisibility = user_get_array_fixed<real_type, 3>(user, "transmisibility", shared->transmisibility, {shared->dim_transmisibility_1, shared->dim_transmisibility_2, shared->dim_transmisibility_3}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_I_1; ++i) {
    for (int j = 1; j <= shared->dim_I_2; ++j) {
      for (int k = 1; k <= shared->dim_I_3; ++k) {
        shared->initial_I[i - 1 + shared->dim_I_1 * (j - 1) + shared->dim_I_12 * (k - 1)] = shared->I_ini[shared->dim_I_ini_12 * (k - 1) + shared->dim_I_ini_1 * (j - 1) + i - 1];
      }
    }
  }
  for (int i = 1; i <= shared->dim_R_1; ++i) {
    for (int j = 1; j <= shared->dim_R_2; ++j) {
      for (int k = 1; k <= shared->dim_R_3; ++k) {
        shared->initial_R[i - 1 + shared->dim_R_1 * (j - 1) + shared->dim_R_12 * (k - 1)] = shared->R_ini[shared->dim_R_ini_12 * (k - 1) + shared->dim_R_ini_1 * (j - 1) + i - 1];
      }
    }
  }
  for (int i = 1; i <= shared->dim_S_1; ++i) {
    for (int j = 1; j <= shared->dim_S_2; ++j) {
      shared->initial_S[i - 1 + shared->dim_S_1 * (j - 1)] = shared->S_ini[shared->dim_S_ini_1 * (j - 1) + i - 1];
    }
  }
  return dust::pars_type<metapop>(shared, internal);
}
template <>
cpp11::sexp dust_info<metapop>(const dust::pars_type<metapop>& pars) {
  const metapop::internal_type internal = pars.internal;
  const std::shared_ptr<const metapop::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"time", "S", "I", "R", "inc"});
  cpp11::writable::list dim(5);
  dim[0] = cpp11::writable::integers({1});
  dim[1] = cpp11::writable::integers({shared->dim_S_1, shared->dim_S_2});
  dim[2] = cpp11::writable::integers({shared->dim_I_1, shared->dim_I_2, shared->dim_I_3});
  dim[3] = cpp11::writable::integers({shared->dim_R_1, shared->dim_R_2, shared->dim_R_3});
  dim[4] = cpp11::writable::integers({shared->dim_inc_1, shared->dim_inc_2, shared->dim_inc_3});
  dim.names() = nms;
  cpp11::writable::list index(5);
  index[0] = cpp11::writable::integers({1});
  index[1] = integer_sequence(2, shared->dim_S);
  index[2] = integer_sequence(shared->offset_variable_I + 1, shared->dim_I);
  index[3] = integer_sequence(shared->offset_variable_R + 1, shared->dim_R);
  index[4] = integer_sequence(shared->offset_variable_inc + 1, shared->dim_inc);
  index.names() = nms;
  size_t len = shared->offset_variable_inc + shared->dim_inc;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
}
